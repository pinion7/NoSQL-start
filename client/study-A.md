# A. 데이터 가공 방식에 따른 성능 차이

- 테스트 파일: index.js
- 테스트 방식은 총 3가지
- case 1: 하드하게 가공하는 방식
- case 2: 관계 활용 방식
- case 3: 문서 내장 방식

</br>

### 1. case1: 하드하게 데이터를 매우 빈번하게 호출하고 가공

- 테스트 결과
- post 10개를 기준으로 그거에 딸린 user, comment 데이터를 불러올 때
- => 평균 3초가 소요
  - 아주아주 성능이 안좋은 것. 0.5초가 마지노선이라고 봐야함

</br>

### 2. case2: 몽구스의 부가 기능(populate)을 잘 활용하여 데이터를 최소한으로 호출하고 가공

- 테스트 결과
- post 10개를 기준으로 populate를 활용해 user, comment 데이터를 불러올 때
- => 평균 0.19초가 소요
  - 심지어 post 200개를 불러오더라도 평균 0.9초에 처리
  - case3에 비해 압도적일 수밖에 없는 가장 큰 이유는 axios 요청횟수에 거대한 차이가 있기 때문임
  - 즉 효율적으로 클라입장에서 성능을 개선하려면 axios 요청 횟수를 줄일 생각을 해야함.

</br>

### 3. case3: 모델에 내장하는 방식으로 populate없이 데이터를 한번에 호출하는 방식

- 테스트 결과
- post 10개를 기준으로 populate를 활용해 user, comment 데이터를 불러올 때
- => 평균 0.05초가 소요
  - populate를 사용하지 않고, model 스키마 자체를 수정해서 애초에 데이터 저장시 확장된 데이터를 저장함
  - 그렇기 때문에 따로 가공하지 않고 이미 가공된 데이터를 호출하게되서 더 성능적으로 진보
  - 심지어 200개를 불러오더라도 평균 0.17초에 처리
  - 다만, case2보다 그렇다고 무조건 더 좋은방식은 아니고, 서비스가 처한 상황에 따라 각각이 다 쓰여야함.

</br>

### 4. 결론

- case 1은 지양해야 하는 방식이지만 case 2와 case 3는 혼용해서 둘다 써야하는 방식이라고 결론내릴 수 있음.
- 다만 그럼 언제 case 2(관계) 방식을 쓰고 언제 case 3(내장) 방식을 써야할까?

#### (1) 일대일, 일대다 모두 해당

![내장 vs 관계 2](https://user-images.githubusercontent.com/83815628/138540832-1bde838d-9a27-4e81-8067-dd96bad08768.png)
</br>

- 만약 콜렉션을 개별적으로도 읽고 조인해서도 읽고 둘다 해야한다 -> 관계 방식이 적절
- 내장하려는 문서가 자주바껴서 스키마를 자주 수정해야 한다 -> 관계 방식이 적절
- 하지만 조인해서 불러오는 일이 대부분이다 -> 내장 방식이 적절
- CUD보다 R비중이 높다 -> 내장 방식이 적절


#### (2) 일대다에만 해당

![내장 vs 관계](https://user-images.githubusercontent.com/83815628/138540831-4c224b9e-d8f4-4c1e-98af-db1a96d535de.png)
</br>

- 데이터 수가 적다 -> 내장 방식이 적절
- 데이터 수가 아주 적은 건 아니다 -> 부분 내장 방식이 적절
- 데이터 수가 많거나, 다양한 조건으로 탐색해야 한다 -> 관계 방식이 적절
