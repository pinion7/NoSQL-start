A. 몽고디비 인덱스 사용법에 대한 학습

1. 인덱스를 사용해야 하는 이유

1) 인덱스를 활용하지 않는 경우

   - 하나의 조건을 find할 때에 모든 다큐먼트를 탐색하게 됨
   - 데이터가 만단위이면 큰 문제가 없으나, 십만, 백만 단위로 올라가는 순간 성능에 큰 문제가 생김

2) 인덱스를 활용하는 경우

   - 인덱스를 활용하면 특정 필드에 오름차순이나 내림차순 정렬을 적용할 수 있음
   - 그렇게 적용이 되는 순간, 이제 db 탐색 시에 마치 바이너리 서치와 비슷한 탐색을 진행하게 됨

------------------------------------------------------------------------ |

2. 성능 비교를 위한 테스트: 1백만 개의 페이커 유저데이터를 만들어서 진행

1) 테스트 1

   - 조건: age가 30인 데이터를 find
   - 인덱스 미사용 결과 -> 750ms 소요, 1백만번 모두 탐색
   - 인덱스 사용 결과 -> 32ms 소요, 2049번 탐색

2) 테스트 2: 페이지네이션 실험

   - 조건 : age가 30 이상인 데이터 + skip 300000 & limit 30000으로 find
   - 인덱스 미사용 결과 -> 300ms 소요, 999145개 스캔해서, 30000개 스킵
   - 인덱스 사용 결과 -> 171ms 소요, 필요한 330000개만 스캔해서, 30000개 스킵
   - 페이지네이션의 원리는 전부 찾아서, 정렬하고 skip해서 limit까지만 뽑아내는 것인데, 인덱스를 사용하면 필요한 부분만 찾고 이미 정렬된 상태에서 skip, limit을 진행하여 굉장히 효율적이게 됨.
   - 페이지네이션 원리 자체가 앞페이지, 마지막페이지를 로딩할때 성능이 젤 우수하고 중간페이지 일수록 속도가 느려질 수 있음. 이유는 앞은 오름차순, 끝은 내림차순으로 정렬하여 보여주면 금방이지만, 중간 페이지는 스캔을 누적해서 해야하고 스킵도 많이할수밖에 없기 때문
   - 애초에 인덱스 자체가 무조건적으로 쓰여야한다기보단, 페이지네이션과 같은 특정 기능 구현시, 효율의 극대화를 위해 필요한 것 같다는 생각

------------------------------------------------------------------------ |

3. 복합키(Compound Key)에 대한 학습

- 2개이상의 필드에 대해 index를 함께 적용하는 것을 복합키라 함. 가령 age 뿐만아니라 username도 사전식 정렬로 함께 적용하고 싶다면, index설정시 두 가지를 모두 add하여 설정해야함.
- 다만 설정한 순서에 맞게만 사용할 수 있음. 조건을 반대로 걸면 불가능.
- 또 다만, age를 오름차순(1), username을 내림차순(-1)으로 인덱스를 주었을 때, sort적용하여 find시, 서로의 값을 반대로(age에 -1, username에 1) 주어도 인덱스 적용이 가능함. 신기한 부분인데 이건 서로 대칭되기만 하면 적용된다고 생각하면 될듯.

------------------------------------------------------------------------ |

4. 분포도(Selectivity)에 대한 학습

- lastname과 age에 각각 index를 걸고, 두 조건을 설정하여 find를 하면 두 개 중에 하나를 선택해서 탐색하게 됨
- 선택하는 기준은 mongoDB가 초반에 두가지 모두를 활용하여 탐색을 하다가, 더 탐색이 용이한 것이 무엇인지를 판단하여, 결국 하나를 선택해서 탐색을 완료하게 되는 거임. (두개를 함께 복합키로 설정한 인덱스를 만들더라도 마찬가지로 위 과정을 통해 선정을 진행함)
- 그렇다면 좋은 인덱스란 무엇인가? -> 분포도를 고려할 줄 아는 것임
- 분포도란 중복값이 얼마나 적게 존재하느냐를 뜻함. 가령 유저의 age는 무수히 다양할 수 있지만, 만약 혈액형이라는 걸 기준으로 한다면 혈액형은 4가지 밖에 존재하지 않기 때문에 중복값이 너무 많음. 이러한 것을 분포도가 안좋다고 말할 수 있음.
- 분포도가 안좋으면 mongoDB가 조건에 따라 데이터를 빠르게 좁히기가 어렵기 때문에 효율을 뽑아내기가 힘듦

------------------------------------------------------------------------ |

5. 인덱스를 무작정 늘린다고 좋을까?

- no. 필요한 인덱스만 적절히 설정하는 것이 중요함.
- 이유 1. 인덱스는 그 자체로 용량을 상당히 먹음. 여러개의 인덱스가 있을 수록 db 용량이 기하급수적으로 늘어날수밖에 없음.
- 이유 2. Read의 성능은 좋아지지만, Create, Update, Delete의 성능은 안좋아질수밖에 없음. 이유는 생성할때마다 그에 해당하는 index에 데이터를 추가해줘야하고, Update도 마찬가지이며, Delete도 그에 맞는 것을 다 삭제해줘야함.

------------------------------------------------------------------------ |

6. 총정리: 인덱스 사용법

- CUD vs R: 을 고려하여 인덱스를 적절히 만들어야 함. 예를 들어 해당 콜렉션이 읽기비중이 확실히 높을때 써야함
- memory: 많이 먹기 때문에 무조건적으로 늘리면 안됨
- query: 어떤 형식으로 쿼리를 날리는 지를 체크하여 그에 맞게 설정해야함
- selectivity: 분포도가 높은 것(중복이 적고 다양하게 분포할 때)들 위주로 인덱스를 사용해야 함

| ------------------------------------------------------------------------ |
| ------------------------------------------------------------------------ |
| ------------------------------------------------------------------------ |

B. 데이터베이스 Transaction 학습

- Transaction은 ACID를 지켜야할 때 꼭 사용되어야함

1. ACID

- Atomicity(원자성): 모두 성공해야함. 하나라도 실패하면 처음으로 롤백
- Consistency(일관성): 항상 일관된 방식으로 처리
- Isolated(독립성): 각각을 호출을 독립적으로 처리
- Durability(보장성): 하드디스크에 영구적 저장을 보장

------------------------------------------------------------------------ |

2. 설명

- 만약 find 이후 save를 통해 업데이트 한다고 가정했을 때, 여러 호출이 동시다발적으로 진행된다면, find로 save가 이루어지는 과정이 완료되기 이전에, 다른 호출에서 find를 또 하게됨으로써 save되지 못한 값을 find하게 됨.

------------------------------------------------------------------------ |

3. 예시 (적절한 예시가 아닐 수 있지만 find -> save 로직이라 가정한다면)

- 가령 게시글 조회수가 10인 게시물을 두번 조회하면 12가 되어야함. 하지만 Transaction이 미적용이라면 count가 10일때를 2번 호출하여 결과적으로 count가 11로 마무리됨.

------------------------------------------------------------------------ |

4. 결론

- Transaction이 적용되면 ACID를 지킬 수 있음
- 하지만 Transaction을 사용하면 아무래도 성능은 떨어짐. 안쓸수있다면 사실 안쓰는게 효율적

| ------------------------------------------------------------------------ |
| ------------------------------------------------------------------------ |
| ------------------------------------------------------------------------ |

C. 무중단 서비스 & 확장성 &

1. 무중단 서비스

- db가 일시적으로 다운되면?
- 과부하로 response time이 너무 길어지면?
  -> 그럼 아무리 백, 프론트를 잘 짜놓았더라도 의미가 없어짐

- 그래서 진행되는 게 첫 CRUD시에 Replica Set(Primary 1, Secondary 2 = 총 3개 세트로 구성됨)이 진행됨
- Primary가 기본적으로 이용이 되고, 다운되면 Secondary가 대체하는 거임
- 그래서 문제가 생겨도 무중단 서비스가 이루어질 수 있는 것

------------------------------------------------------------------------ |

2. 확장성

- db 설계를 비롯, 관계설정을 이용한 populate이용, 부분 문서내장방식, 인덱스 등 모든 최적화를 완료했음에도 너무 데이터 양이 많아져서 효율성이 더 개선이 안될 때는 돈을 더 써서 더 사양이 좋은 db서버 사양을 향상시켜야함.

- Vectical(수직) Scale: 그냥 더 좋은 사양을 쓰는 방법. 하지만 한계가 있음. 아무리 좋은 걸 쓴다한들 기술력에 한계는 있는 법임.

- Horizontal(수평) Scale (Sharded Cluster): 적당한 사양을 여러개 쓰는 방법. db를 수평적으로 확장하는 것은 한계가 없음 걍 수를 늘리면 되기 때문. 그럼 CRUD가 분리가 되어서 성능 유지가 가능함. 관계형 데이터베이스에서도 적용은 가능하지만 훨씬 어렵다고 함.

- RDBMS가 그만큼 오래된 방식이기 때문인데, 수십년전엔 그렇게 많은 데이터를 처리할 일이 없었고 수평적 확장의 필요성을 못느꼈기 때문에 수직적 확장에만 집중을 한 것. 그래서 발전과정에서 수평적 확장을 고려하지 못한 부분이 많아, 현재 수평적 확장이 불가능까진 아니지만 난이도가 높은 것.

- 반면 NoSQL은 수평적 확장을 목적으로 두고 설계된 방식이기도 하기 때문에 수월함.

- RDBMS vs NoSQL 간의 id 생성 방식 비교
- RDBMS(Auto Increment)
- NoSQL(ObjectId: 시간 + 랜덤숫자 +Auto Increment로 구성)
  => 단일 서버에서는 상관이 없지만, 수평적 확장으로 여러 db 서버로 분산 저장해야 한다고한다면 Auto Increment는 중복될수밖에 없음.

------------------------------------------------------------------------ |

3. RDBMS vs NoSQL

(1) 큰 차이점: CRUD

- Read의 경우: RDBMS는 복잡, NoSQL은 간단
- Create, Update, Delete의 경우: RDBMS는 간단, NoSQL은 복잡

(2) Read 성능

- NoSQL는 그냥 id값 하나에 접근하면 바로 뽑아서 반환.
- RDBMS는 단순한 읽기도 SQL 언어로 내부적인 처리가 많이 들어감. 이를 보완하기 위해 쿼리문 자체에 해당하는 결과값을 캐시 메모리에 저장하여 활용하는 방식을 많이 씀. (ex) redis)
- 문서내장(Nesting) >>> SQL > Aggregate 순으로 성능이 우수함.
- Aggregate는 몽고디비의 SQL 언어라고 보면됨

(3) Read 유연함

- SQL === Aggregate >>> 문서내장(Nesting)
- 마음대로 조합하고 가공하는 건 역시 Nesting은 어렵기 때문

(4) MongoDB를 활용하면 두마리 토끼를 어느정도 잡는 것도 가능함

| --------------- | API server | Data Engineering |
| 한번에 읽는 데이터양 | 적음 ------ | 매우 많음 -------- |
| Read Pattern -- | 거의 고정 -- | 자주 바뀔 수 있음 -- |
| 빈도 \***\*\_\_\_\*\*** | 매우 높음 -- | 매우 낮음 -------- |
| response time - | 낮을수록 좋음 | 높아도 상관 없음 --- |

- API server는 frontend를 위한 것, Data Engineering은 dashboard, ML을 위한 것임
- API server에는 Nesting을 사용하면 됨
- Data Engineering의 경우엔 Aggregate를 쓰면 됨
- 물론 필요에 따라 API server에서도 Aggregate를 사용할 수 있지만, 적은 데이터를 다루는 일이 아니라면 비효율적. 되도록 안쓰는게 맞는듯.

(5) Consistency

- 데이터를 입력할 때 RDBMS는 그냥 해당하는 테이블에만 데이터를 넣으면 됨. 그렇게만 해도 일관성이 보장됨. (다 관계로 핸들링이 되기 때문)
- 반면 MongoDB는 내장하거나 복제한 부분에 대해서, 양쪽 콜렉션에서 각각 다 개발자가 일일이 데이터를 저장하는 로직을 세심히 구현해줘야함. 안그러면 일관성이 보장되지 않음.
- 상황에 따른 노하우가 필요한 게 NoSQL

------------------------------------------------------------------------ |
